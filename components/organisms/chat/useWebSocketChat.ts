import { getWebSocketUrl } from "@/lib/getWebSocketUrl";
import { addMessage } from "@/lib/store/messagesSlice";
import { sanitizeMarkdown } from "@/lib/utils";
import { patientDatabase, testMedSpa, testNurse } from "@/mock/chat.data";
import WebSocket from "isomorphic-ws";
import { useEffect, useRef, useState } from "react";
import { useDispatch } from "react-redux";
import { v4 as uuid } from "uuid";
import { ChatMessage, WebSocketResponseMessage } from "./types";
import { extractChunk, logMetadata } from "./utils";

import type { AppDispatch } from "@/lib/store";
// Import the async thunk for fetching dynamic layout
import { fetchDynamicLayout } from "@/lib/store/dynamicLayoutSlice";

// Import the mock logic from the file specified in the Canvas
import { generateMockAiResponse } from "@/mock/mockTera/chatWebSocketMockLogic";

interface UseChatWebSocketProps {
  currentPatientId: keyof typeof patientDatabase;
  isPatientContextEnabled: boolean;
  forceFresh: boolean;
  cacheDebug: boolean;
  onMessage?: (messages: ChatMessage[]) => void; // Optional callback when messages state updates
}

/**
 * Extracts the actual message content after a "Bot: " marker.
 * If the marker is not found, returns the original content.
 * @param rawContent The raw string content from the AI response.
 * @returns The processed string, trimmed.
 */
const getBotActualResponse = (rawContent: string): string => {
  const botMarker = "Bot: ";
  const markerIndex = rawContent.indexOf(botMarker);
  if (markerIndex !== -1) {
    return rawContent.substring(markerIndex + botMarker.length).trim();
  }
  return rawContent.trim(); // Fallback if "Bot: " is not found
};

// Determine if client-side mocking is enabled
// const IS_DEVELOPMENT = process.env.NODE_ENV === 'development';
// To enable mock, set NEXT_PUBLIC_ENABLE_MOCK_CHAT=true in your .env.local or environment variables
// @TODO: make it false after demo
const ENABLE_MOCK_CHAT = true; // || IS_DEVELOPMENT && process.env.NEXT_PUBLIC_ENABLE_MOCK_CHAT === 'true';

export function useWebSocketChat({
  currentPatientId,
  isPatientContextEnabled,
  forceFresh,
  cacheDebug,
  // onMessage, // This prop was defined but not used; consider if it's needed
}: UseChatWebSocketProps) {
  const socketRef = useRef<WebSocket | null>(null);
  const retryCount = useRef(0);
  const maxRetries = 3; // Max retries for real WebSocket connection
  const retryDelay = 2000; // Delay between retries for real WebSocket
  const retryTimeout = useRef<NodeJS.Timeout | null>(null);

  // Initial connected state depends on whether mocking is enabled
  // biome-ignore lint/complexity/noUselessTernary: ignored
  const [connected, setConnected] = useState(ENABLE_MOCK_CHAT ? true : false);
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const dispatch = useDispatch<AppDispatch>(); // Typed dispatch for thunks
  const [streamBuffer, setStreamBuffer] = useState(""); // Used for real streaming
  const [loading, setLoading] = useState(false); // Loading state for AI response
  const conversationId = useRef(`conv_${Date.now()}`);

  /**
   * Handles the mock response generation and state updates.
   * Simulates WebSocket events for chat_stream_start and chat_response.
   * @param aiFullResponse The full response string generated by the mock logic.
   */
  const handleMockResponse = (aiFullResponse: string) => {
    // 1. Simulate chat_stream_start to set loading state
    setLoading(true);
    setStreamBuffer(""); // Clear any stream buffer (though not actively used in this mock path)
    console.log("[MockChat] Simulating chat_stream_start");

    // 2. Simulate a delay then a single chat_response
    // (Client-side mock doesn't simulate chunk-by-chunk streaming for simplicity here)
    setTimeout(
      () => {
        const actualBotMessageForDisplay = getBotActualResponse(aiFullResponse);

        const chatResponseMessage: ChatMessage = {
          id: uuid(),
          sender: "ai",
          text: sanitizeMarkdown(actualBotMessageForDisplay), // Sanitize for display
        };

        setMessages((prev) => [...prev, chatResponseMessage]);
        dispatch(addMessage(chatResponseMessage));
        setLoading(false);
        // logMetadata({ mock: true, source: "client-side", timestamp: new Date().toISOString() }); // Example mock metadata
        console.log(
          "[MockChat] Simulating chat_response. Display text:",
          actualBotMessageForDisplay,
        );

        // 3. Dispatch action to fetch dynamic layout using the processed bot message
        if (actualBotMessageForDisplay.trim()) {
          console.log(
            "[MockChat] Dispatching fetchDynamicLayout with processed markdown:",
            actualBotMessageForDisplay,
          );
          dispatch(fetchDynamicLayout(actualBotMessageForDisplay));
        }
      },
      800 + Math.random() * 1200,
    ); // Simulate network delay (0.8s to 2s)
  };

  /**
   * Sends a message, either to the real WebSocket or handled by the mock logic.
   * @param text The user's message text.
   */
  const sendMessage = (text: string) => {
    const patient = patientDatabase[currentPatientId]; // Get current patient context
    const newMessage: ChatMessage = { id: uuid(), sender: "user", text };

    setMessages((prev) => [...prev, newMessage]);
    dispatch(addMessage(newMessage));
    console.log("[Chat] User message added to state:", newMessage);

    if (ENABLE_MOCK_CHAT) {
      console.log("[MockChat] Handling sendMessage with client-side mock logic.");
      const mockPatientContext =
        isPatientContextEnabled && patient
          ? { id: patient.id } // Pass necessary patient context
          : undefined;
      const aiResponse = generateMockAiResponse(text, mockPatientContext);
      handleMockResponse(aiResponse);
    } else {
      // Logic for sending message via real WebSocket
      if (!connected || !socketRef.current) {
        console.warn("[Chat] Real WebSocket not connected. Cannot send message.");
        // Optionally, queue the message or inform the user
        return;
      }
      const payload: any = {
        type: "chat",
        nurseId: testNurse.id,
        message: text,
        conversationId: conversationId.current,
        medspaId: testMedSpa.medspaId,
        medSpaContext: testMedSpa, // Consider if this large object is always needed
        streaming: true, // Request streaming from real backend
        cacheControl: { debug: cacheDebug, forceFresh },
        debug: { timestamp: new Date().toISOString() },
      };
      if (isPatientContextEnabled && patient) {
        payload.patientId = patient.id;
        payload.patientInfo = patient; // Consider if full patientInfo is needed or just ID
        payload.debug.activePatientContext = patient.id;
      }
      socketRef.current.send(JSON.stringify(payload));
      console.log("[Chat] Message sent to real WebSocket:", payload);
    }
  };

  // Effect for establishing and managing WebSocket connection OR handling mock setup
  // biome-ignore lint/correctness/useExhaustiveDependencies: reason for ignoring
  useEffect(() => {
    if (ENABLE_MOCK_CHAT) {
      console.log(
        "[MockChat] Client-side mock chat is ENABLED. Real WebSocket connection will be skipped.",
      );
      if (!connected) setConnected(true); // Ensure 'connected' state is true for mock
      return; // Skip WebSocket connection logic
    }

    // --- Real WebSocket Connection Logic (if mock is not enabled) ---
    console.log("[Chat] Client-side mock chat is DISABLED. Attempting real WebSocket connection.");
    const connect = async () => {
      let token = "";
      try {
        const tokenResponse = await fetch("/api/token"); // Ensure this endpoint exists and works
        if (!tokenResponse.ok) {
          console.error("Failed to fetch token:", tokenResponse.status, await tokenResponse.text());
          // Implement retry or error display for token fetch failure
          return;
        }
        const tokenData = await tokenResponse.json();
        token = tokenData.token;
        if (!token) {
          console.error("Token not found in response from /api/token");
          return;
        }
      } catch (error) {
        console.error("Error fetching token:", error);
        return;
      }

      const wsUrl = getWebSocketUrl(); // Ensure this function returns the correct URL
      const url = new URL(wsUrl);
      url.searchParams.set("token", token);
      url.searchParams.set("medspaId", testMedSpa.medspaId); // Or dynamically get medspaId

      console.log("[Chat] Attempting to connect to real WebSocket:", url.toString());
      const socket = new WebSocket(url.toString());
      socketRef.current = socket;

      socket.onopen = () => {
        setConnected(true);
        retryCount.current = 0;
        if (retryTimeout.current) {
          clearTimeout(retryTimeout.current);
          retryTimeout.current = null;
        }
        socket.send(JSON.stringify({ type: "auth", token: token.replace(/^Bearer\s+/, "") }));
        console.log("[Chat] Real WebSocket connected and authenticated.");
      };

      socket.onmessage = (event: MessageEvent<string>) => {
        const msg: WebSocketResponseMessage = JSON.parse(event.data);
        console.log("[Chat] Real WebSocket message received:", msg);
        switch (msg.type) {
          case "chat_stream_start":
            setLoading(true);
            setStreamBuffer("");
            break;
          case "chat_stream_chunk":
            setStreamBuffer((prev) => prev + extractChunk(msg.chunk));
            break;
          case "chat_stream_complete": {
            const rawAiResponseContent = msg.response?.content || streamBuffer;
            const actualBotMessage = getBotActualResponse(rawAiResponseContent);
            const streamMessage: ChatMessage = {
              id: uuid(),
              sender: "ai",
              text: sanitizeMarkdown(actualBotMessage),
            };
            setMessages((prev) => [...prev, streamMessage]);
            dispatch(addMessage(streamMessage));
            setLoading(false);
            setStreamBuffer("");
            logMetadata(msg.response?.metadata);
            if (actualBotMessage.trim()) {
              dispatch(fetchDynamicLayout(actualBotMessage));
            }
            break;
          }
          case "chat_response": {
            const rawAiResponseContent = msg.response?.content || "";
            const actualBotMessage = getBotActualResponse(rawAiResponseContent);
            const chatResMessage: ChatMessage = {
              id: uuid(),
              sender: "ai",
              text: extractChunk(actualBotMessage), // extractChunk might be similar to sanitizeMarkdown
            };
            setMessages((prev) => [...prev, chatResMessage]);
            dispatch(addMessage(chatResMessage));
            setLoading(false);
            logMetadata(msg.response?.metadata);
            if (actualBotMessage.trim()) {
              dispatch(fetchDynamicLayout(actualBotMessage));
            }
            break;
          }
          case "error":
            setLoading(false);
            console.error("Real WebSocket Server Error:", msg.error);
            // Potentially display this error to the user or add to messages list
            break;
          default:
            console.warn("Received unhandled real WebSocket message type:", msg.type);
        }
      };

      socket.onclose = (event: any) => {
        setConnected(false);
        console.log("Real WebSocket closed:", event.code, event.reason);
        if (retryCount.current < maxRetries && !ENABLE_MOCK_CHAT) {
          // Only retry if not in mock mode
          retryCount.current += 1;
          console.log(
            `WebSocket connection closed. Retrying attempt ${retryCount.current}/${maxRetries} in ${retryDelay / 1000}s...`,
          );
          if (retryTimeout.current) clearTimeout(retryTimeout.current);
          retryTimeout.current = setTimeout(connect, retryDelay);
        } else if (!ENABLE_MOCK_CHAT) {
          console.error(`Real WebSocket connection failed after ${maxRetries} retries.`);
        }
      };
      socket.onerror = (errorEvent: WebSocket.ErrorEvent) => {
        console.error("Real WebSocket error observed:", errorEvent.message);
        // Consider if socket.close() is needed here or if onclose will handle it
      };
    };

    connect(); // Initial connection attempt

    return () => {
      // Cleanup function
      if (retryTimeout.current) {
        clearTimeout(retryTimeout.current);
      }
      if (socketRef.current) {
        console.log("Closing real WebSocket connection on component unmount/effect cleanup.");
        socketRef.current.onopen = null; // Remove listeners to prevent actions on closed socket
        socketRef.current.onmessage = null;
        socketRef.current.onerror = null;
        socketRef.current.onclose = null;
        socketRef.current.close();
        socketRef.current = null;
      }
    };
    // Added dispatch to dependency array.
    // Other dependencies like getWebSocketUrl, testMedSpa.medspaId might be needed if they can change and require re-connection.
  }, [currentPatientId, isPatientContextEnabled, forceFresh, cacheDebug, dispatch]);

  return {
    connected,
    messages,
    streamBuffer,
    loading,
    sendMessage,
  };
}
